import { HISTORY } from '@/shared/constants'
import type { ProjectMeta, ProjectState, StoredFile } from '@/shared/infrastructure/db'
import { autoGenOutlineFromPages } from '@/shared/utils/auto-gen-tree'
import {
  resolveMetadataDirtyFlag,
  resolveOutlineTreeForHydration,
} from '@/domains/workspace/application/project-session.service'
import type {
  DocumentMetadata,
  OutlineNode,
  PageEntry,
  PageReference,
  SecurityMetadata,
  SourceFile,
} from '@/shared/types'
import type { SerializedCommand } from '@/domains/history/domain/commands/types'

export interface ProjectHydrationDocumentStore {
  reset: () => void
  addSourceFile: (sourceFile: SourceFile) => void
  setProjectTitle: (title: string) => void
  setOutlineDirty: (value: boolean) => void
  setPages: (pages: PageEntry[]) => void
  setMetadata: (next: Partial<DocumentMetadata>, markDirty?: boolean) => void
  setMetadataDirty: (value: boolean) => void
  setSecurity: (next: Partial<SecurityMetadata>) => void
  setOutlineTree: (tree: OutlineNode[], markDirty?: boolean) => void
  contentPages: PageReference[]
  sources: Map<string, SourceFile>
}

export interface ProjectHydrationHistoryStore {
  clearHistory: () => void
  rehydrateHistory: (
    serializedHistory: SerializedCommand[],
    pointer?: number,
    updatedAt?: number,
  ) => void
}

export interface ProjectHydrationUiState {
  setZoom: (value: number) => void
  setIgnoredPreflightRuleIds: (ids: string[]) => void
}

export interface HydrateProjectWorkspaceInput {
  meta: ProjectMeta
  state: ProjectState
  files: StoredFile[]
  documentStore: ProjectHydrationDocumentStore
  historyStore: ProjectHydrationHistoryStore
  uiState?: ProjectHydrationUiState | null
  defaultGridZoom: number
  clearThumbnailCache: () => void
}

export function toSourceFile(file: StoredFile): SourceFile {
  return {
    id: file.id,
    filename: file.filename,
    fileSize: file.fileSize,
    pageCount: file.pageCount,
    addedAt: file.addedAt,
    color: file.color,
    pageMetaData: file.pageMetaData ?? [],
    isImageSource: file.isImageSource ?? false,
    outline: file.outline,
    metadata: file.metadata,
  }
}

export function hydrateProjectWorkspace(input: HydrateProjectWorkspaceInput): void {
  const {
    meta,
    state,
    files,
    documentStore,
    historyStore,
    uiState,
    defaultGridZoom,
    clearThumbnailCache,
  } = input

  documentStore.reset()
  historyStore.clearHistory()
  clearThumbnailCache()

  for (const file of files) {
    documentStore.addSourceFile(toSourceFile(file))
  }

  documentStore.setProjectTitle(meta.title)
  uiState?.setZoom(state.zoom ?? defaultGridZoom)
  documentStore.setOutlineDirty(Boolean(state.outlineDirty))
  documentStore.setPages(state.pageMap ?? [])
  uiState?.setIgnoredPreflightRuleIds(state.ignoredPreflightRuleIds ?? [])

  if (state.metadata) {
    documentStore.setMetadata(state.metadata, false)
  }

  documentStore.setMetadataDirty(
    resolveMetadataDirtyFlag({
      metadataDirty: state.metadataDirty,
      metadata: state.metadata,
    }),
  )

  if (state.security) {
    documentStore.setSecurity(state.security)
  }

  const autoOutline = autoGenOutlineFromPages(documentStore.contentPages, documentStore.sources)
  const hydratedOutline = resolveOutlineTreeForHydration({
    persistedOutlineTree: state.outlineTree,
    outlineDirty: state.outlineDirty,
    autoGeneratedOutline: autoOutline,
  })

  if (hydratedOutline.length > 0) {
    documentStore.setOutlineTree(hydratedOutline, false)
  }

  historyStore.rehydrateHistory(
    state.history ?? [],
    state.historyPointer ?? HISTORY.POINTER_START,
    state.updatedAt,
  )
}
