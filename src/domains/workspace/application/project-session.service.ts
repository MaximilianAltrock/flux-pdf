import { DEFAULT_PROJECT_TITLE, HISTORY, ZOOM } from '@/shared/constants'
import type { ProjectMeta } from '@/shared/infrastructure/db'
import type { ProjectSnapshot } from '@/domains/document/domain/project'
import type { SerializedCommand } from '@/domains/history/domain/commands/types'
import type {
  DocumentMetadata,
  OutlineNode,
  PageEntry,
  PageReference,
  SecurityMetadata,
} from '@/shared/types'

export function normalizeProjectTitle(title: string | undefined): string {
  const next = String(title ?? '').trim()
  return next.length > 0 ? next : DEFAULT_PROJECT_TITLE
}

export function isProjectTrashed(meta: ProjectMeta | null | undefined): boolean {
  return Boolean(meta && typeof meta.trashedAt === 'number')
}

export function clampProjectGridZoom(value: number): number {
  return Math.min(ZOOM.MAX, Math.max(ZOOM.MIN, value))
}

export function isDefaultProjectMetadata(value: {
  title?: string
  author?: string
  subject?: string
  keywords?: string[]
}): boolean {
  return (
    (value.title ?? '').trim() === DEFAULT_PROJECT_TITLE &&
    !(value.author ?? '').trim() &&
    !(value.subject ?? '').trim() &&
    (value.keywords ?? []).length === 0
  )
}

export function coerceOutlineTree(value: unknown): OutlineNode[] {
  if (!Array.isArray(value)) return []
  return value as OutlineNode[]
}

export function getFirstContentPage(pages: ReadonlyArray<PageReference>): PageReference | null {
  for (const page of pages) {
    if (page && !page.isDivider) return page as PageReference
  }
  return null
}

export function buildDefaultProjectMetadata(options: {
  projectTitle: string
  defaultAuthor: string
}): DocumentMetadata {
  return {
    title: options.projectTitle,
    author: options.defaultAuthor.trim(),
    subject: '',
    keywords: [],
  }
}

export function buildInitialProjectSnapshot(options: {
  zoom: number
  metadata: DocumentMetadata
}): ProjectSnapshot {
  return {
    activeSourceIds: [],
    pageMap: [],
    history: [],
    historyPointer: HISTORY.POINTER_START,
    zoom: options.zoom,
    outlineTree: [],
    outlineDirty: false,
    metadata: options.metadata,
    security: undefined,
    metadataDirty: false,
    ignoredPreflightRuleIds: [],
  }
}

export function buildPersistedProjectMeta(options: {
  existingMeta: ProjectMeta
  title: string
  pageCount: number
  now: number
  thumbnail: Blob | undefined
}): ProjectMeta {
  return {
    ...options.existingMeta,
    title: options.title,
    pageCount: options.pageCount,
    updatedAt: options.now,
    thumbnail: options.thumbnail,
  }
}

export function buildPersistedProjectSnapshot(options: {
  activeSourceIds: string[]
  pageMap: PageEntry[]
  history: SerializedCommand[]
  historyPointer: number
  zoom: number
  outlineTree: OutlineNode[]
  outlineDirty: boolean
  metadata: DocumentMetadata
  security: SecurityMetadata | undefined
  metadataDirty: boolean
  ignoredPreflightRuleIds: string[]
}): ProjectSnapshot {
  return {
    activeSourceIds: options.activeSourceIds,
    pageMap: options.pageMap,
    history: options.history,
    historyPointer: options.historyPointer,
    zoom: options.zoom,
    outlineTree: options.outlineTree,
    outlineDirty: options.outlineDirty,
    metadata: options.metadata,
    security: options.security,
    metadataDirty: options.metadataDirty,
    ignoredPreflightRuleIds: options.ignoredPreflightRuleIds,
  }
}

export function resolveMetadataDirtyFlag(options: {
  metadataDirty?: boolean
  metadata?: DocumentMetadata
}): boolean {
  if (options.metadataDirty !== undefined) {
    return options.metadataDirty
  }

  if (!options.metadata) {
    return false
  }

  return !isDefaultProjectMetadata(options.metadata)
}

export function resolveOutlineTreeForHydration(options: {
  persistedOutlineTree?: unknown[]
  outlineDirty?: boolean
  autoGeneratedOutline: OutlineNode[]
}): OutlineNode[] {
  const restoredTree = coerceOutlineTree(options.persistedOutlineTree)
  if (restoredTree.length > 0) {
    return restoredTree
  }

  if (!options.persistedOutlineTree?.length && !options.outlineDirty) {
    return options.autoGeneratedOutline
  }

  return []
}

