1. "The Stamper" (Bates Numbering & Watermarking)

Target: Lawyers, Accountants, Admin.

The Pain Point: Adding "Page 1 of 50" or "CONFIDENTIAL" to a merged document usually requires expensive software like Acrobat Pro.
The Flux Solution: A non-destructive layer that renders on top of your grid.

    Feature Set:

        Bates Numbering: Automatically sequence pages (e.g., Ex_001, Ex_002) across multiple source files.

        Watermarks: Text ("DRAFT") or Image (Company Logo) overlays.

        Positioning: 9-point grid (Top-Left, Center, Bottom-Right, etc.).

    The "Flux" Twist:

        Live Preview: Since you are already rendering thumbnails, render the watermark text on the canvas layer immediately.

        Non-Destructive: If I merge 3 files, I can apply numbering. If I then delete Page 2, the numbers auto-update (3 becomes 2).

    Technical Implementation:

        state in store setWatermark

        dedicated command

        On Export, use pdf-lib’s drawText or drawImage method on every page.

2. "Asset Miner" (Extract Images)

Target: Developers, Designers.

The Pain Point: You get a PDF with high-res photos embedded, but you can't get them out. Taking a screenshot lowers the quality.
The Flux Solution: Deep extraction.

    Feature Set:

        Extract All Images: Scans the PDF binary stream for image objects (JPEG/PNG) and downloads them as a ZIP.

        Extract Text: Dumps all text into a .txt or .md file.

    The "Flux" Twist:

        The Inspector: When a user selects a page, show an "Assets" tab in the Inspector sidebar listing "3 Images, 2 Fonts."

        Click-to-Download: Allow clicking an image in that list to save just that raw asset.

    Technical Implementation:

        pdf-lib allows iterating through PDF objects. You can find XObject images and export the raw bytes without re-encoding them (preserving original quality).

3. "Preflight Linter" (Sanity Check)

Target: Print Shops, OCD Power Users.

The Pain Point: You merge 10 files. Some are A4, some are US Letter. Some are portrait, one is landscape. You don't notice until you print it and it looks terrible.
The Flux Solution: Automated Quality Control (Linting).

    Feature Set:

        Size Mismatch Warning: "Warning: Page 4 is US Letter, but the rest are A4."

        Resolution Warning: "Page 2 is a low-res scan (72 DPI)."

        Orientation Check: "Mixed orientations detected."

    The "Flux" Twist:

        Status Bar: Add a "Problems" icon in the footer (like VS Code).

        Quick Fix: Clicking the error offers a one-click fix (e.g., "Resize all to A4", "Rotate all to Portrait").

    Technical Implementation:

        When loading files (usePdfManager), read the MediaBox (dimensions) of every page. Store this somewhere.

        A simple computed property compares them and flags outliers.

This is the feature that solidifies FluxPDF as an Engineering Tool rather than just a PDF viewer.

In professional printing and publishing software (like Adobe InDesign), "Preflight" is a standard term. It means "Checking the document for errors before it goes to the printer."

Here is the in-depth breakdown of how to build the FluxPDF Preflight Linter.

1. The Concept: "Linting for Documents"

Just as ESLint checks your code for bugs before you commit, the Flux Linter checks your PDF for layout inconsistencies before you export.

The Problem it solves: "Frankenstein PDFs."

    User merges a signed contract (Scanned Image, A4) with a digital cover letter (Word Export, US Letter).

    Result: When printed, the printer jams or shrinks pages randomly. The user doesn't notice until it's too late.

The Solution:
Passive, real-time analysis of the pageMap. If Page 1 is A4 and Page 2 is US Letter, a Warning appears in the status bar. 2. The User Experience (UX)

The UI should mimic the "Problems" tab in VS Code.
A. The Status Bar Indicator

Located in the footer or the top-right toolbar.

    Clean State: [✓ Preflight Passed] (Green text).

    Dirty State: [⚠ 3 Problems] (Amber text).

B. The "Problems" Panel

When the user clicks the warning indicator, a bottom drawer slides up (like the terminal in VS Code).

    List Item: "Inconsistent Page Sizes"

        Detail: "Page 3 (8.5 x 11 in) does not match the majority size (A4)."

        Action Button (The Quick Fix): [Fix: Scale to A4]

C. Visual Feedback on Grid

The grid thumbnail for the problematic page gets a tiny yellow triangle in the corner. Hovering it shows the specific error. 3. The Logic: What are we checking?

We don't need AI. We just need geometry. Here are the 4 MVP rules:
Rule 1: Dimension Consistency (The "A4 vs Letter" Check)

    Logic: Calculate the "Mode" (most common) width/height in the document.

    Flag: Any page that deviates by more than 5% from the Mode.

    Fix: "Scale page to match document."

Rule 2: Orientation Consistency

    Logic: Check if the document is primarily Portrait or Landscape.

    Flag: A Landscape page in a 90% Portrait document.

    Fix: "Rotate 90°". (Note: Sometimes mixed orientation is intentional, so this is a Warning, not an Error).

Rule 3: File Size / Complexity

    Logic: Check the fileSize of the source file divided by page count.

    Flag: If one page is estimated to be > 5MB (likely a raw uncompressed photo).

    Fix: "Rasterize & Compress Page."

Rule 4: Metadata Health

    Flag: If Title is "Untitled" or "Microsoft Word - Document1.docx".

    Fix: "Edit Metadata."

4. Technical Implementation

This fits perfectly into your composables architecture. It is a read-only analyzer of the store.
Step 1: Define the Types
code TypeScript

// src/types/linter.ts

export type Severity = 'error' | 'warning' | 'info'

export interface LintRule {
id: string
label: string
check: (pages: PageReference[]) => LintResult[]
}

export interface LintResult {
ruleId: string
severity: Severity
message: string
pageIds: string[] // Which pages caused this?
fixAction?: () => void // The Command to run to fix it
}

Step 2: The Linter Composable

Create src/composables/usePreflight.ts. This watches the pages array and re-runs logic instantly.
code TypeScript

import { computed } from 'vue'
import { useDocumentStore } from '@/stores/document'
import type { LintResult, LintRule } from '@/types/linter'

export function usePreflight() {
const store = useDocumentStore()

// --- Helper: Get Dimensions ---
// In a real app, you'd store page width/height in the PageReference
// during the import phase (usePdfManager).
// For now, let's assume PageReference has width/height properties.

const rules: LintRule[] = [
{
id: 'size-mismatch',
label: 'Inconsistent Page Sizes',
check: (pages) => {
if (pages.length < 2) return []

        // 1. Find the most common width (The "Standard")
        const widths = pages.map(p => Math.round(p.width || 0))
        const modeWidth = getMode(widths)

        // 2. Find outliers
        const outliers = pages.filter(p => {
          const w = Math.round(p.width || 0)
          return Math.abs(w - modeWidth) > 10 // 10pt tolerance
        })

        if (outliers.length === 0) return []

        return [{
          ruleId: 'size-mismatch',
          severity: 'warning',
          message: `${outliers.length} pages have different sizes than the rest of the document.`,
          pageIds: outliers.map(p => p.id),
          fixAction: () => console.log('Trigger Resize Command') // TODO: Implement Command
        }]
      }
    },
    // ... Add Orientation Rule here

]

const problems = computed(() => {
// Only run if we have pages
if (store.pageCount === 0) return []

    return rules.flatMap(rule => rule.check(store.pages))

})

const problemCount = computed(() => problems.value.length)
const isHealthy = computed(() => problemCount.value === 0)

return {
problems,
problemCount,
isHealthy
}
}

// Utility
function getMode(arr: number[]): number {
return arr.sort((a,b) =>
arr.filter(v => v===a).length - arr.filter(v => v===b).length
).pop() || 0
}

Step 3: Prerequisites (Data Update)

For this to work, you need to know the Dimensions of the pages. Currently, your PageReference only stores IDs.

Update usePdfManager.ts to read the MediaBox during import.
code TypeScript

// src/composables/usePdfManager.ts

// Inside loadPdfFile...
for (let i = 0; i < pdfDoc.numPages; i++) {
const page = await pdfDoc.getPage(i + 1) // pdfjs
const viewport = page.getViewport({ scale: 1 }) // Get natural dimensions

pageRefs.push({
id: crypto.randomUUID(),
// ...
// NEW DATA:
width: viewport.width,
height: viewport.height,
originalRotation: viewport.rotation
})
}

4. "The Redactor" (Privacy Mode)

Target: HR, Legal, Finance.

The Pain Point: You need to hide a Social Security Number or a price on an invoice. If you just draw a black rectangle over it in a standard editor, the text underneath is often still selectable and searchable. (This is a common security failure).
The Flux Solution: Secure, destructive redaction.

    Feature Set:

        Draw-to-Redact: User draws a rectangle over an area.

        Visuals: The area turns black (or white) immediately.

    The "Flux" Twist:

        "Burn Mode": On export, FluxPDF doesn't just add a black box. It creates a Composite Image of that specific page section, effectively "rasterizing" the secret data out of existence.

        Safety Check: A toast warning on export: "2 Redactions applied. This data will be permanently removed."

    Technical Implementation:

        UI: A standard Canvas overlay on the DiffModal or PreviewModal.

        Export: Use pdf-lib to overlay an opaque rectangle, and optionally flatten that page to an image to ensure the underlying text stream is destroyed.

The Security Philosophy: "Burn Mode"

Standard PDF annotations are just layers on top. The text underneath remains searchable and copyable.
FluxPDF's "Burn Mode":
When a page has redactions, we do not just draw a rectangle in the PDF. During export, we:

    Render the page to a high-resolution image (Rasterize) including the black boxes.

    Replace the original vector page with this image.

    Result: The underlying text data, metadata, and hidden layers are physically destroyed. It is now just pixels.

Data Model Updates (src/types/index.ts)

We need to store redaction coordinates relative to the PDF's internal point system

We need full Undo/Redo support. If a user accidentally covers a signature, they must be able to undo it.

A. The Coordinate Math Problem

The image in the modal is scaled by CSS (transform: scale(zoom)). It is also responsive (CSS object-fit: contain).
We need to translate Mouse Event Pixels -> PDF Points.

The Formula:

    Get the rendered DOM width of the <img>.

    Get the original PDF width (stored in PageReference.originalWidth).

    Ratio = PDF_Width / DOM_Width.

    PDF_X = Mouse_OffsetX * Ratio.

We modify PagePreviewModal.vue to support a drawing mode.

The Component Update (PagePreviewModal.vue)

We add a toolbar and an overlay div.

he "Burn Mode" Exporter (src/composables/usePdfExport.ts)

This is the most critical logic. We intercept pages with redactions and reroute them through a rasterization process.

The Coordinate "Gotcha" (Y-Axis)

    Web/DOM: (0,0) is Top-Left.

    PDF: (0,0) is usually Bottom-Left.

    Solution: Store coordinates in the Store as Top-Left based (matching the UI). Only convert to Bottom-Left if you are drawing vectors in pdf-lib.

    However: Since our "Burn Mode" draws to an HTML Canvas (which is also Top-Left), we do not need to invert Y. This simplifies the math significantly. Storing Top-Left coordinates is the correct choice for this rasterization strategy.

5. "The Padder" (Print Prep)

Target: Students, Print Shops.

The Pain Point: You want to print a document double-sided, but Chapter 1 ends on an odd page, so Chapter 2 starts on the back of Chapter 1. You need to insert blank pages manually to force chapters to start on the right-hand side.
The Flux Solution: Smart Injection.

    Feature Set:

        Insert Blank: A context menu action to insert a totally blank white page.

        "Normalize Length": A command that ensures every sub-document (or the whole file) has an even number of pages by appending a blank page to the end if necessary.

    The "Flux" Twist:

        Ghost Page: In the grid, blank pages render with a subtle "Empty Page" watermark or dashed X so the user knows it's intentionally blank, not a rendering error.

    Technical Implementation:

        pdf-lib has addPage(). Very low effort.

6. "Project Dashboard" (Session Management)

Target: Multi-taskers.

The Pain Point: Local-first apps usually only allow one "state" at a time. If I'm working on Contract_A, and I need to quickly fix Invoice_B, I have to clear my workspace or open a new tab.
The Flux Solution: A File System in the Browser.

    Feature Set:

        Home Screen: When you click the Logo, instead of just a menu, show a Dashboard Overlay.

        Recent Projects: A grid showing snapshots of your last 5 sessions (stored in IndexedDB).

        Stats: "Edited 2 hours ago • 14 Pages".

    The "Flux" Twist:

        Instant Switch: Switching projects doesn't reload the page. It just swaps the pageMap and historyStack in memory. It feels instant.

    Technical Implementation:

        You already have db.session. Change the schema to store an array of sessions, or a sessions table.

        db.sessions.add({ id: uuid(), title: 'Contract A', ... }).

        This is a significant architectural expansion that moves FluxPDF from a "Single-File Utility" to a "Workspace Application" (like Figma or VS Code).

Here is the technical breakdown of how to implement the Project Dashboard properly.

1. The Routing Strategy

Yes, this requires a Router. We should move away from a simple App.vue state toggle and use Vue Router.
The Routes

    / (Dashboard): The hub. Shows recent projects, global settings, and "New Project" entry points.

    /project/:id (The Editor): The actual workspace. The :id corresponds to a UUID in IndexedDB.

Behavior

    On Load: Check localStorage. If lastActiveProjectId exists, redirect immediately to /project/:id (VS Code behavior).

    Clicking the Logo: Inside the Editor, clicking the logo navigates back to / (Dashboard).

2. The Data Model (Database Schema Update)

We need to split the "Heavy Data" (Page Maps, History) from the "Light Data" (Project Metadata) so the Dashboard loads instantly without parsing thousands of history steps.

This is a significant architectural expansion that moves FluxPDF from a "Single-File Utility" to a "Workspace Application" (like Figma or VS Code).

Here is the technical breakdown of how to implement the Project Dashboard properly.

1. The Routing Strategy

Yes, this requires a Router. We should move away from a simple App.vue state toggle and use Vue Router.
The Routes

    / (Dashboard): The hub. Shows recent projects, global settings, and "New Project" entry points.

    /project/:id (The Editor): The actual workspace. The :id corresponds to a UUID in IndexedDB.

Behavior

    On Load: Check localStorage. If lastActiveProjectId exists, redirect immediately to /project/:id (VS Code behavior).

    Clicking the Logo: Inside the Editor, clicking the logo navigates back to / (Dashboard).

2. The Data Model (Database Schema Update)

We need to split the "Heavy Data" (Page Maps, History) from the "Light Data" (Project Metadata) so the Dashboard loads instantly without parsing thousands of history steps.

Update src/db/db.ts:
code TypeScript

// 1. Light Meta Table (For the Dashboard)
export interface ProjectMeta {
id: string
title: string
thumbnail?: string // Blob URL of the first page (cached)
pageCount: number
updatedAt: number
createdAt: number
}

// 2. Heavy State Table (Loaded only when opening the editor)
export interface ProjectState {
id: string // Matches ProjectMeta.id
pageMap: PageReference[]
history: SerializedCommand[]
historyPointer: number
zoom: number
....
// We do NOT store files here. Files remain in the global 'files' table.
}

// Update DB Class
export class FluxDatabase extends Dexie {
projects!: Table<ProjectMeta>
states!: Table<ProjectState>
files!: Table<StoredFile> // Shared asset pool

constructor() {
super('FluxPDF_DB')
this.version(2).stores({
projects: 'id, updatedAt', // Index by date for sorting
states: 'id',
files: 'id'
})
}
}

3. The Dashboard UI Layout

The Dashboard should look like a "File Explorer" or the "Home" tab in Figma.
A. Layout Structure

    Left Sidebar (Navigation):

        [Clock Icon] Recents

        [Star Icon] Favorites (Future feature)

        [Trash Icon] Trash (Soft deleted projects)

        [Settings Icon] Global Settings

    Main Content (Grid):

        Header: "Recents" + Sort Dropdown + Search Bar.

        The "New" Card: A dashed-border card. "Create New Project" or "Import PDF".

        Project Cards: A grid of cards representing existing sessions.

B. The Project Card Component

Each card needs specific details to be useful:

    Visual: A nice thumbnail of Page 1 (generated when the project is saved).

    Title: Contract_Draft_v2.

    Meta: 14 Pages • 2h ago.

    Actions (Context Menu):

        Open

        Rename (Inline edit on the card)

        Duplicate (Clones the ProjectState and ProjectMeta)

        Delete

5. Transition Logic (Crucial for UX)

When you click a project, the transition needs to be smooth.

    Store Reset: Before navigating to /project/:id, you must ensure the Pinia store (document.ts) is reset.

    Route Guard: In EditorView.vue, use onMounted to grab the :id from the route.

        Call usePdfManager.loadProject(id).

        This function queries db.states for the heavy JSON.

        It populates the store.

        Optimization: While loading, show a skeleton UI that matches the Editor layout exactly.

1. The Architecture: The "Hot Swap"

We treat the Pinia Store (document.ts) like a Game Cartridge slot.

    The Console: The EditorView.vue (The UI).

    The Cartridge: The Project Data in IndexedDB.

When the route changes from /project/A to /project/B:

    We Serialize the current store (Project A) to IDB (Save Game).

    We Wipe the store (Eject Cartridge).

    We Inject Project B data from IDB into the store (Insert Cartridge).

    The UI updates reactively.

Since IndexedDB is local, this happens in ~10-50ms. To the human eye, it is instant. 2. The Project Manager Composable

We need a new composable to handle this "Eject/Insert" logic safely.

Create: src/composables/useProjectManager.ts
