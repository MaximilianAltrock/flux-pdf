1. "The Stamper" (Bates Numbering & Watermarking)

Target: Lawyers, Accountants, Admin.

The Pain Point: Adding "Page 1 of 50" or "CONFIDENTIAL" to a merged document usually requires expensive software like Acrobat Pro.
The Flux Solution: A non-destructive layer that renders on top of your grid.

    Feature Set:

        Bates Numbering: Automatically sequence pages (e.g., Ex_001, Ex_002) across multiple source files.

        Watermarks: Text ("DRAFT") or Image (Company Logo) overlays.

        Positioning: 9-point grid (Top-Left, Center, Bottom-Right, etc.).

    The "Flux" Twist:

        Live Preview: Since you are already rendering thumbnails, render the watermark text on the canvas layer immediately.

        Non-Destructive: If I merge 3 files, I can apply numbering. If I then delete Page 2, the numbers auto-update (3 becomes 2).

    Technical Implementation:

        state in store setWatermark

        dedicated command

        On Export, use pdf-lib’s drawText or drawImage method on every page.

2. "Asset Miner" (Extract Images)

Target: Developers, Designers.

The Pain Point: You get a PDF with high-res photos embedded, but you can't get them out. Taking a screenshot lowers the quality.
The Flux Solution: Deep extraction.

    Feature Set:

        Extract All Images: Scans the PDF binary stream for image objects (JPEG/PNG) and downloads them as a ZIP.

        Extract Text: Dumps all text into a .txt or .md file.

    The "Flux" Twist:

        The Inspector: When a user selects a page, show an "Assets" tab in the Inspector sidebar listing "3 Images, 2 Fonts."

        Click-to-Download: Allow clicking an image in that list to save just that raw asset.

    Technical Implementation:

        pdf-lib allows iterating through PDF objects. You can find XObject images and export the raw bytes without re-encoding them (preserving original quality).

3. "Preflight Linter" (Sanity Check)

Target: Print Shops, OCD Power Users.

The Pain Point: You merge 10 files. Some are A4, some are US Letter. Some are portrait, one is landscape. You don't notice until you print it and it looks terrible.
The Flux Solution: Automated Quality Control (Linting).

    Feature Set:

        Size Mismatch Warning: "Warning: Page 4 is US Letter, but the rest are A4."

        Resolution Warning: "Page 2 is a low-res scan (72 DPI)."

        Orientation Check: "Mixed orientations detected."

    The "Flux" Twist:

        Status Bar: Add a "Problems" icon in the footer (like VS Code).

        Quick Fix: Clicking the error offers a one-click fix (e.g., "Resize all to A4", "Rotate all to Portrait").

    Technical Implementation:

        When loading files (usePdfManager), read the MediaBox (dimensions) of every page. Store this somewhere.

        A simple computed property compares them and flags outliers.

4. "The Redactor" (Privacy Mode)

Target: HR, Legal, Finance.

The Pain Point: You need to hide a Social Security Number or a price on an invoice. If you just draw a black rectangle over it in a standard editor, the text underneath is often still selectable and searchable. (This is a common security failure).
The Flux Solution: Secure, destructive redaction.

    Feature Set:

        Draw-to-Redact: User draws a rectangle over an area.

        Visuals: The area turns black (or white) immediately.

    The "Flux" Twist:

        "Burn Mode": On export, FluxPDF doesn't just add a black box. It creates a Composite Image of that specific page section, effectively "rasterizing" the secret data out of existence.

        Safety Check: A toast warning on export: "2 Redactions applied. This data will be permanently removed."

    Technical Implementation:

        UI: A standard Canvas overlay on the DiffModal or PreviewModal.

        Export: Use pdf-lib to overlay an opaque rectangle, and optionally flatten that page to an image to ensure the underlying text stream is destroyed.

5. "The Padder" (Print Prep)

Target: Students, Print Shops.

The Pain Point: You want to print a document double-sided, but Chapter 1 ends on an odd page, so Chapter 2 starts on the back of Chapter 1. You need to insert blank pages manually to force chapters to start on the right-hand side.
The Flux Solution: Smart Injection.

    Feature Set:

        Insert Blank: A context menu action to insert a totally blank white page.

        "Normalize Length": A command that ensures every sub-document (or the whole file) has an even number of pages by appending a blank page to the end if necessary.

    The "Flux" Twist:

        Ghost Page: In the grid, blank pages render with a subtle "Empty Page" watermark or dashed X so the user knows it's intentionally blank, not a rendering error.

    Technical Implementation:

        pdf-lib has addPage(). Very low effort.

6. "Project Dashboard" (Session Management)

Target: Multi-taskers.

The Pain Point: Local-first apps usually only allow one "state" at a time. If I'm working on Contract_A, and I need to quickly fix Invoice_B, I have to clear my workspace or open a new tab.
The Flux Solution: A File System in the Browser.

    Feature Set:

        Home Screen: When you click the Logo, instead of just a menu, show a Dashboard Overlay.

        Recent Projects: A grid showing snapshots of your last 5 sessions (stored in IndexedDB).

        Stats: "Edited 2 hours ago • 14 Pages".

    The "Flux" Twist:

        Instant Switch: Switching projects doesn't reload the page. It just swaps the pageMap and historyStack in memory. It feels instant.

    Technical Implementation:

        You already have db.session. Change the schema to store an array of sessions, or a sessions table.

        db.sessions.add({ id: uuid(), title: 'Contract A', ... }).

        This is a significant architectural expansion that moves FluxPDF from a "Single-File Utility" to a "Workspace Application" (like Figma or VS Code).

Here is the technical breakdown of how to implement the Project Dashboard properly.

1. The Routing Strategy

Yes, this requires a Router. We should move away from a simple App.vue state toggle and use Vue Router.
The Routes

    / (Dashboard): The hub. Shows recent projects, global settings, and "New Project" entry points.

    /project/:id (The Editor): The actual workspace. The :id corresponds to a UUID in IndexedDB.

Behavior

    On Load: Check localStorage. If lastActiveProjectId exists, redirect immediately to /project/:id (VS Code behavior).

    Clicking the Logo: Inside the Editor, clicking the logo navigates back to / (Dashboard).

2. The Data Model (Database Schema Update)

We need to split the "Heavy Data" (Page Maps, History) from the "Light Data" (Project Metadata) so the Dashboard loads instantly without parsing thousands of history steps.

This is a significant architectural expansion that moves FluxPDF from a "Single-File Utility" to a "Workspace Application" (like Figma or VS Code).

Here is the technical breakdown of how to implement the Project Dashboard properly.

1. The Routing Strategy

Yes, this requires a Router. We should move away from a simple App.vue state toggle and use Vue Router.
The Routes

    / (Dashboard): The hub. Shows recent projects, global settings, and "New Project" entry points.

    /project/:id (The Editor): The actual workspace. The :id corresponds to a UUID in IndexedDB.

Behavior

    On Load: Check localStorage. If lastActiveProjectId exists, redirect immediately to /project/:id (VS Code behavior).

    Clicking the Logo: Inside the Editor, clicking the logo navigates back to / (Dashboard).

2. The Data Model (Database Schema Update)

We need to split the "Heavy Data" (Page Maps, History) from the "Light Data" (Project Metadata) so the Dashboard loads instantly without parsing thousands of history steps.

Update src/db/db.ts:
code TypeScript

// 1. Light Meta Table (For the Dashboard)
export interface ProjectMeta {
id: string
title: string
thumbnail?: string // Blob URL of the first page (cached)
pageCount: number
updatedAt: number
createdAt: number
}

// 2. Heavy State Table (Loaded only when opening the editor)
export interface ProjectState {
id: string // Matches ProjectMeta.id
pageMap: PageReference[]
history: SerializedCommand[]
historyPointer: number
zoom: number
....
// We do NOT store files here. Files remain in the global 'files' table.
}

// Update DB Class
export class FluxDatabase extends Dexie {
projects!: Table<ProjectMeta>
states!: Table<ProjectState>
files!: Table<StoredFile> // Shared asset pool

constructor() {
super('FluxPDF_DB')
this.version(2).stores({
projects: 'id, updatedAt', // Index by date for sorting
states: 'id',
files: 'id'
})
}
}

3. The Dashboard UI Layout

The Dashboard should look like a "File Explorer" or the "Home" tab in Figma.
A. Layout Structure

    Left Sidebar (Navigation):

        [Clock Icon] Recents

        [Star Icon] Favorites (Future feature)

        [Trash Icon] Trash (Soft deleted projects)

        [Settings Icon] Global Settings

    Main Content (Grid):

        Header: "Recents" + Sort Dropdown + Search Bar.

        The "New" Card: A dashed-border card. "Create New Project" or "Import PDF".

        Project Cards: A grid of cards representing existing sessions.

B. The Project Card Component

Each card needs specific details to be useful:

    Visual: A nice thumbnail of Page 1 (generated when the project is saved).

    Title: Contract_Draft_v2.

    Meta: 14 Pages • 2h ago.

    Actions (Context Menu):

        Open

        Rename (Inline edit on the card)

        Duplicate (Clones the ProjectState and ProjectMeta)

        Delete

5. Transition Logic (Crucial for UX)

When you click a project, the transition needs to be smooth.

    Store Reset: Before navigating to /project/:id, you must ensure the Pinia store (document.ts) is reset.

    Route Guard: In EditorView.vue, use onMounted to grab the :id from the route.

        Call usePdfManager.loadProject(id).

        This function queries db.states for the heavy JSON.

        It populates the store.

        Optimization: While loading, show a skeleton UI that matches the Editor layout exactly.

1. The Architecture: The "Hot Swap"

We treat the Pinia Store (document.ts) like a Game Cartridge slot.

    The Console: The EditorView.vue (The UI).

    The Cartridge: The Project Data in IndexedDB.

When the route changes from /project/A to /project/B:

    We Serialize the current store (Project A) to IDB (Save Game).

    We Wipe the store (Eject Cartridge).

    We Inject Project B data from IDB into the store (Insert Cartridge).

    The UI updates reactively.

Since IndexedDB is local, this happens in ~10-50ms. To the human eye, it is instant. 2. The Project Manager Composable

We need a new composable to handle this "Eject/Insert" logic safely.

Create: src/composables/useProjectManager.ts
